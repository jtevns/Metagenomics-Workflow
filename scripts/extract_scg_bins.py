#!/usr/bin/env python
"""
Extract bins with given SCG (Single Copy genes) criteria. Criteria can be set
as a combination of the maximum number of missing SCGs and the maximum number
of multicopy SCGs. By default the script selects from pairs of scg_tsvs and
fasta_files, the pair that has the highest number of approved bins. In case
there are multiple with the max amount of approved bins, it takes the one that
has the highest sum of bases in those bins. If that is the same, it selects the
first one passed as argument.

One can also group the pairs of scg_tsvs and fasta_files with the --groups
option so one can for instance find the best binning per sample.
"""
import sys
import argparse
from os.path import join as ospj
import logging

import pandas as pd
from Bio import SeqIO

from concoct.utils import dir_utils


def get_approved_bins(scg_tsv, max_missing_scg, max_multicopy_scg):
    """Return approved bins as pandas dataframe from given scg_tsv as generated
    with COG_table.py"""
    scgdf = pd.read_csv(scg_tsv, sep="\t")
    # number of multicopy genes
    multi_scgs = scgdf.iloc[:, list(range(3, len(scgdf.columns)))] \
            .apply(lambda x: x > 1).sum(axis=1)
    # number of missing scgs
    miss_scgs = scgdf.iloc[:, list(range(3, len(scgdf.columns)))] \
            .apply(lambda x: x == 0).sum(axis=1)
    app_bins = scgdf[(miss_scgs <= max_missing_scg) & (multi_scgs <=
        max_multicopy_scg)].loc[:, ["Cluster", "Contigs"]]

    return app_bins


def sum_bases_in_bins(scgdf, fasta_file):
    """Sum number of bases in given bins. The scgdf is expected to be a pandas
    dataframe constructed from scg_tsv (generated by COG_table.py)."""
    contigs = [c for cs in scgdf.Contigs for c in cs.split("|")]
    with open(fasta_file) as handle:
        rdict = SeqIO.to_dict(SeqIO.parse(handle, "fasta"))
    return sum([len(rdict[c].seq) for c in contigs])


def write_approved_bins(app_binsdf, fasta_file, output_folder, prefix):
    """Write given approved bins from scg_tsv to given
    output_folder/prefix_binid.fa"""
    # get fasta dict
    with open(fasta_file) as handle:
        rdict = SeqIO.to_dict(SeqIO.parse(handle, "fasta"))

    # print approved bins
    dir_utils.mkdir_p(output_folder)
    for bin_id, contigs in app_binsdf.loc[:, ["Cluster",
            "Contigs"]].as_matrix():
        contig_ids = contigs.split("|")
        out_file = ospj(output_folder,
                "{prefix}_bin{bin_id}.fa".format(bin_id=bin_id, prefix=prefix))
        with open(out_file, "w") as handle:
            for cid in contig_ids:
                handle.write(">{}\n{}\n".format(cid, rdict[cid].seq))


def get_winning_bins(scg_tsvs, fasta_files, max_missing_scg, max_multicopy_scg):
    """From pairs of scg_tsvs and fasta_files select the pair that has the
    highest number of approved bins. In case there are multiple with the max
    amount of approved bins, take the one that has the highest sum of bases in
    those bins. If that is the same select the first one passed as argument."""
    # find the scg_tsv with most approved bins
    app_bins_dfs = [get_approved_bins(scg_tsv, max_missing_scg,
        max_multicopy_scg)
            for scg_tsv in scg_tsvs]
    max_app_bins_index = [i for i, ab in enumerate(app_bins_dfs) if len(ab) ==
            len(max(app_bins_dfs, key=len))]
    # if there are more select one with highest sum of bases in approved bins
    # or the first passed argument if that is equal as well
    if len(max_app_bins_index) > 1:
        max_bases = max([sum_bases_in_bins(app_bins_dfs[i], fasta_files[i]) for
            i in max_app_bins_index])
        max_bases_index = [i for i in max_app_bins_index if
                sum_bases_in_bins(app_bins_dfs[i], fasta_files[i]) ==
                max_bases]
        winning_index = max_bases_index[0]
    else:
        winning_index = max_app_bins_index[0]

    return winning_index, app_bins_dfs[winning_index]


def parse_input():
    """Return input arguments using argparse"""
    parser = argparse.ArgumentParser(description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument("--output_folder", required=True, help="Output folder")
    parser.add_argument("--scg_tsvs", required=True, nargs='+', help="Single "
            "Copy  Genes (SCG) tsvs as outpututted by COG_table.py. Should "
            "have the same ordering as fasta_files.")
    parser.add_argument("--fasta_files", required=True, nargs='+', help="Fasta "
            " files. Should have the same ordering as scg_tsvs")
    parser.add_argument("--names", required=True, nargs='+', help="Names for "
            "each scg_tsv and fasta_file pair. This is used as the prefix "
            "for the outputted bins.")
    parser.add_argument("--groups", nargs='+', default=None, help="Select the best candidate "
            "for each group of scg_tsv and fasta_file pairs. Number of group "
            "names given should be equal to the number of scg_tsv and fasta_file "
            "pairs. Identical group names indicate same groups.")
    parser.add_argument("--max_missing_scg", type=int, default=2)
    parser.add_argument("--max_multicopy_scg", type=int, default=4)
    args = parser.parse_args()
    if not (len(args.names) == len(args.scg_tsvs)
            and len(args.scg_tsvs) == len(args.fasta_files)):
        raise Exception
    if args.groups and len(args.groups) != len(args.names):
        raise Exception
    if len(args.names) != len(set(args.names)):
        raise Exception
    return args


def select_and_write_approved_bins(output_folder, scg_tsvs, fasta_files, names,
        max_missing_scg, max_multicopy_scg):
    """Output approved bins in output folder. Find best scg scoring bins if
    necessary"""
    if len(scg_tsvs) > 1:
        logging.info("Finding scg_tsv of {} with highest number of approved "
                "bins with max_missing_scg {} and max_multicopy_scg {}"
                .format(" ".join(names), max_missing_scg, max_multicopy_scg))
        winning_index, app_binsdf = get_winning_bins(scg_tsvs, fasta_files,
                max_missing_scg, max_multicopy_scg)
        name = names[winning_index]
        logging.info("Winning scg_tsv: {}".format(name))
        fasta_file = fasta_files[winning_index]
    else:
        logging.info("Get approved bins for {}".format(names[0]))
        app_binsdf = get_approved_bins(scg_tsvs[0], max_missing_scg,
                max_multicopy_scg)
        name = names[0]
        fasta_file = fasta_files[0]
    logging.info("Writing approved bins to {}*.fa".format(ospj(output_folder,
        name)))
    write_approved_bins(app_binsdf, fasta_file, output_folder, name)
    logging.info("Done writing")


def main(args):
    """
    Run select_and_write_approved_bins for each group if necessary. Otherwise
    run on all given arguments.
    """
    # create logger
    logging.basicConfig(
        stream=sys.stdout,
        level=logging.INFO,
        format='%(asctime)s:%(levelname)s:%(name)s:%(message)s',
    )
    if args.groups:
        group_indices = {g:[i for i, j in enumerate(args.groups) if j == g] for g in args.groups}
        for g, indices in group_indices.items():
            logging.info("Selecting best SCG clustering for group "
                    "{}".format(g))
            select_and_write_approved_bins(args.output_folder, [args.scg_tsvs[i] for i in indices],
                    [args.fasta_files[i] for i in indices], [args.names[i] for i in indices],
                    args.max_missing_scg, args.max_multicopy_scg)
    else:
        logging.info("Selecting best SCG clustering of all given files")
        select_and_write_approved_bins(args.output_folder, args.scg_tsvs, args.fasta_files,
                args.names, args.max_missing_scg, args.max_multicopy_scg)
    logging.info("Finished")


if __name__ == "__main__":
    main(parse_input())
